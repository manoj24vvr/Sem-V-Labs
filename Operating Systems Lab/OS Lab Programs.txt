		Template

#!/bin/bash
echo -e "Enter Filename: \c"
read -r file
echo -e "Enter Directory: \c"
read -r direc
if [ -d $direc ]; then
        touch $direc/$file.sh
        echo '#!/bin/bash' > $direc/$file.sh
        echo ' ' >> $direc/$file.sh
        echo '########################################' >> $direc/$file.sh
        echo '# Title: ' `echo $file` >> $direc/$file.sh
        echo '# Description: ' >> $direc/$file.sh
        echo '# Name: Atyam V V R Manoj' >> $direc/$file.shvi 2.c
        echo '# Date: ' `date +%D` >> $direc/$file.sh
        echo '########################################' >> $direc/$file.sh
        echo '#  Start  #' >> $direc/$file.sh
        echo '' >> $direc/$file.sh
        echo '#  End  #' >> $direc/$file.sh
        echo "$file is created successfully"
else
        echo '$direc does not exist'
fi



#!/bin/bash
echo -e "Enter Filename: \c"
read -r file
direc=$"shellscript"
touch $direc/$file.c
echo '#include<stdio.h>' > $direc/$file.c
echo '#include<sys/types.h>' >> $direc/$file.c
echo '#include<unistd.h>' >> $direc/$file.c
echo '#include<stdlib.h>' >> $direc/$file.c
echo '#include<sys/wait.h>' >> $direc/$file.c
echo ' ' >> $direc/$file.c
echo '//########################################' >> $direc/$file.c
echo '// Title: ' `echo $file` >> $direc/$file.c
echo '// Description: ' >> $direc/$file.c
echo '// Name: Atyam V V R Manoj' >> $direc/$file.c
echo '// Reg No.: 200968108' >> $direc/$file.c
echo '// Date: ' `date +%D` >> $direc/$file.c
echo '//########################################' >> $direc/$file.c
echo '//*  Start  *' >> $direc/$file.c
echo '' >> $direc/$file.c
echo '//*  End  *' >> $direc/$file.c
echo "$file is created successfully"
~            					

WEEK-1

dse151@telnet:~/OS108/Week1July29$ tree
.
|-- TempOS
|   |-- Subtemp1
|   |   |-- File5.py
|   |   `-- Subtemp2
|   |       |-- File1
|   |       |-- File2.c
|   |       `-- File3.cpp
|   `-- Subtemp3
|       |-- File5.py
|       |-- Prg1.py
|       |-- Prg2.py
|       `-- Subtemp4
|           `-- File4.java
`-- TestFolder

6 directories, 8 files

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: To find given no. is Even or Odd
* Date: 
*/

Q1

					WEEK-2


Q1

/*
Name: Atyam V V R Manoj
Registration Number: 200968108
Program: 
Date: 05/08/2022
*/

#!/bin/bash
echo "Enter a positive number: "
read number
if [ `expr $number % 2 `  = 0 ]
then echo "Given number is even"
else echo "Given number is odd"
fi

Q2


// Name: Atyam V V R Manoj
// Registration Number: 200968108
// Program: Check username and print appropriate message
// Date: 05/08/2022


#!/bin/bash
echo "Enter the name: "
read name
if [ $name = "Alice" ]
then echo "Good morning"
elif [ $name = "Peter" ]
then echo "Good night"
fi

Q3

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Print grade based on cgpa
* Date: 05/08/2022
*/

#!/bin/bash
read -p "Enter cgpa of user: " cgpa
if [ $cgpa -eq 10 ]
then echo "Grade is A+"
elif [ $cgpa -eq 9 ]
then echo "Grade is A"
elif [ $cgpa -eq 8 ]
then echo "Grade is B"
elif [ $cgpa -eq 7 ]
then echo "Grade is C"
else echo "Grade is D"
fi


	`				WEEK_3

Q1

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Find largest of 3 numbers
* Date: 12/08/2022
*/

#!/bin/bash
echo "Enter three Integers:"
read a b c
if [ $a -gt $b -a $a -gt $c ]
then echo "$a is Greatest"
elif [ $b -gt $c -a $b -gt $a ]
then echo "$b is Greatest"
else echo "$c is Greatest"
fi

Q2

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Print 5,4,3,2,1 using while loop
* Date: 12/08/2022
*/

#!/bin/bash
num=5
while [ $num -gt 0 ]
do
echo $num
num=$[num - 1]
done

Q3

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Print given number in reverse order
* Date: 12/08/2022
*/

#!/bin/bash
read -p "Enter a number: " num
rem=0
revnum=0
while [ $num -gt 0 ]
do
        rem=$(( $num % 10 ))
        revnum=$(($revnum * 10 + $rem))
        num=$(($num / 10))
done
echo "Reverse order is $revnum"

Q4

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Print sum of digits of given number
* Date: 12/08/2022
*/

#!/bin/bash
read -p "Give a number: " num
sum=0 rem=0
while [ $num -gt 0 ]
do
        rem=$(( $num % 10 ))
        sum=$(( $sum + $rem ))
        num=$(( $num / 10 ))
done
echo "Sum of the digits is: $sum"

Q5

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Print contents of a file
* Date: 12/08/2022
*/

#!/bin/bash
echo "Choose one of the below option to print the lines of the file 'file.txt' from: "
echo "1. Beginning"
echo "2. Ending"
read k
read -p "How many lines do you want to print?" n
if [ $k = 1 ]
then cat -n file.txt | head -$n
elif [ $k = 2 ]
then cat -n file.txt | tail -$n
else echo "Invalid input. Choose again!"
fi


1 listing

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Select from list
* Date: 12/08/2022
*/

echo "1. Display Files"
echo "2. Display all Files"
echo "3. Delete files from directory"
echo "4. Exit from shell"
while [ 1 ]
do
        echo "Enter your choice: "
        read ch
        case $ch in
                1) echo `ls -l`;;
                2) echo `ls -al`;;
                3)      read -p "Enter filename to delete: " fname
                        if [ -f $fname ]; then
                                `rm $fname`
                                echo "$fname is deleted"
                        else
                                echo "$fname doesn't exist"
                        fi;;
                4) read -p "Exit [y/n]: " ex
                        if [ $ex = "y" ]; then
                                exit
                        fi
        esac
done

2 changingFAP

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Take user input file name and change executable
* Date: 12/08/2022
*/

read -p "Enter Filename: " fname
if [ -f $fname ]; then
        if [ -x $fname ]; then
                echo "$fname is Executable!"
        else
                echo `chmod u+x $fname`
                echo "File Permissions Updated!. $fname is Executable"
        fi
else
        echo "$fname doesn't exist"
fi


1 compareStrings

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Comparing two strings for equality
* Date: 12/08/2022
*/

read -p "Enter string 1: " str1
read -p "Enter string 2: " str2
flag=0
if [ -z $str1 ]; then
        echo "String 1 is empty"
        flag=1
fi
if [ -z $str2 ]; then
        echo "String 2 is empty"
        flag=1
fi
if [ $flag = 1 ]; then
        exit
fi
if [ $str1 = $str2 ]; then
        echo "String 1 and String 2 are same"
else
        echo "String 1 and String 2 are different"
fi


2 checkFiles

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: checking given files
* Date: 12/08/2022
*/

read -p "Enter the number of files to access: " num
for (( i=1; i<=$num; i++ ))
do
        echo "Fetching File count: $i"
        read -p "Enter Filename: " fname
        if [ -f $fname ]; then
                echo "Opening file $fname..."
                echo `cat $fname`
                if [ -x $fname ]; then
                        echo "$fname is executable"
                else
                        echo "$fname is not executable"
                fi
        elif [ -d $fname ]; then
                echo "Number of files in the directory $fname: "
                echo `find ./$fname -type f | wc -l`
        else
                echo "$fname does not exist"
        fi
done







					WEEK-4

					PROCESSES
Q1.c

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: To block a parent process until child completes using wait system call
* Date: 26/08/2022
*/

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>
int main(){
        pid_t pid;
        pid=fork();
        if (pid<0){
                fprintf(stderr, "Fork Failed");
                exit(-1);
        }
        else if(pid==0){
                execlp("/bin/ls","ls",NULL);
        }
        else{
                wait(NULL);
                printf("Child Completed\n");
                exit(0);
        }
}

Q2.c

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: program to create a child process. Display the process IDs of the process, parent and child (if any) in both the parent and child processes.
* Date: 26/08/2022
*/

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>
int main(){
        pid_t pid;
        pid=fork();

        if (pid<0){
                fprintf(stderr, "Fork Failed");
                exit(-1);
        }
        else if(pid==0){
                printf("PID of New Child Process: %d\n", getpid());
                printf("PID of its Parent Process: %d\n", getppid());
        }
        else{
                wait(NULL);
                printf("Child Complete\n");
                printf("PID of Main Process: %d\n", getpid());
                printf("PID of Parent of Main Process: %d\n", getppid());
                exit(0);
        }
}

Q3.c

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Accept an array of integers. Display the unsorted array in the parent process. Create a child process. 
* Sort and display the sorted array in the child process. 
* Date: 26/08/2022
*/

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>
int main(){
        int n,arr[20],i,j,min;
        printf("Enter array size: ");
        scanf("%d", &n);
        printf("Enter Array Elements: ");
        for(i=0;i<n;i++)
                scanf("%d",&arr[i]);
        pid_t pid;
        pid=fork();
        if(pid < 0){
                fprintf(stderr,"Fork Failed");
                exit(-1);
        }
        else if(pid == 0){
                for(i=0;i<n;i++){
                        min=i;
                        for(j=i+1;j<n;j++){
                                if(arr[j]<arr[min])
                                        min=j;
                        }
                        int temp=arr[i];
                        arr[i]=arr[min];
                        arr[min]=temp;
                }
                printf("The sorted Array: ");
                for(i=0;i<n;i++)
                        printf("%d ",arr[i]);
                printf("\n");
        }
        else{
                printf("The Array: ");
                for(i=0;i<n;i++)
                        printf("%d ",arr[i]);
                printf("\n");
                wait(NULL);
                printf("Child Complete\n");
        }
        return 0;
}

Q4.c

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Create a orphan process (parent dies before child, child process adopted by “init” process) and display the PID of parent of child before and after it becomes orphan. 
* Use sleep (n) in the child to delay the termination.
* Date: 26/08/2022
*/

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>
int main(){
        pid_t pid;
        printf("PID of Main Process: %d\n", getpid());

        pid=fork();

        if(pid<0){
                fprintf(stderr,"Fork Failed");
                exit(-1);
        }
        else if(pid==0){
                printf("Child Process just created\n");
                printf("PID of Child Process: %d\n",getpid());
                printf("PID of Parent Process: %d\n",getppid());
                sleep(5);
                printf("After Parent process is died\n");
                printf("PID of Child Process: %d\n",getpid());
                printf("PID of Child Process: %d\n",getppid());
        }
        else{
                printf("Parent process\n");
        }
        return 0;

}

Q5.c

/*
* Name: Atyam V V R Manoj
* Registration Number: 200968108
* Program: Write a C program to simulate ls command
* Date: 26/08/2022
*/

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>
int main(){
        pid_t pid;
        pid = fork();
        if(pid<0){
                fprintf(stderr,"Fork Failed");
                exit(-1);
        }
        else if(pid==0){
                execlp("/bin/ls","ls",NULL);
        }
        else{
                wait(NULL);
                printf("Child Completed\n");
                exit(0);
        }
        return 0;
}

					SYSTEM CALLS
Q1
#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
#include<sys/wait.h>
#include<stdlib.h>

int main() {
        int pid;
        printf("Current process Id: %d \n", getpid());
        pid = fork();
        if(pid < 0) {
                printf("Failed to fork");
                exit(-1);
        }
        else if(pid == 0)
                printf("Child Process is running \n");
        else {
                wait(NULL);
                printf("The Child Process has completed execution and the parent is running \n");
                exit(0);
        }
}

Q2
#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
#include<sys/wait.h>

int main() {
        int pid;
        pid = fork();
        if(pid == 0) {
                // running for child
                printf("Child Process: \n");
                printf("Process id: %d \n", getpid());
                printf("Parent id: %d \n", getppid());
        }
        else {
                wait(NULL);
                printf("Parent Process: \n");
                printf("Process id: %d \n", getpid());
                printf("Parent id: %d \n", getppid());
                printf("Child id: %d \n", pid);
        }
}

Q3
#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
#include<sys/wait.h>

int main() {
        int arr[5], pid;
        printf("Enter 5 integers: ");
        for(int i = 0; i < 5; i++)
                scanf("%d", &arr[i]);
        pid = fork();
        if(pid == 0) {
                printf("Child Process: \n");
                printf("Sorted Array: ");
                for(int i = 0; i < 5 - 1; i++)
                        for(int j = 0; j < 5 - i - 1; j++)
                                if(arr[j] > arr[j+1]) {
                                        int temp = arr[j];
                                        arr[j] = arr[j+1];
                                        arr[j+1] = temp;
                                }
                for(int i = 0; i < 5; i++)
                        printf("%d ", arr[i]);
                printf("\n");
        }
        else {
                printf("Parent Process: \n");
                printf("Unsorted array: ");
                for(int i = 0; i < 5; i++)
                        printf("%d ", arr[i]);
                printf("\n");
        }
}

Q4
#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
#include<sys/wait.h>

int main() {
        int pid = fork();
        if(pid == 0) {
                printf("The current parent process is: %d \n", getppid());
                sleep(5);
                printf("The parent process of orphan is: %d \n", getppid());
        }
}

Q5
#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<unistd.h>
#include<sys/wait.h>

int main() {
        int pid;
        pid = fork();
        if(pid == 0) {
                printf("Child process: \n");
                execlp("/bin/ls", "ls", NULL);
        }
        else {
                wait(NULL);
                printf("Parent process: \n");
                printf("Cild has completed running ls \n");
                exit(0);
        }
}


					SHELL-SCRIPTS


#Author Name : Atyam V V R Manoj
#Date : 26/9/2022
#Registration Number : 200968108
#Shell Script Name : Exercise for sort, cut and tr filters

#!/bin/bash
# The command to delete a single line of text is sed "1d" filename

touch BMI_2022.dat

echo "1. Enter Data"
echo "2. Display Data"
echo "3. Exit"

read -p "Enter your choice: " choice

if [ $choice -eq 1 ]
then
        read -p "Please enter the Name: " name
        read -p "Please enter the Location: " loc
        read -p "Please enter the State: " state
        read -p "Please enter the Age: " age
        read -p "Please enter the Month of Entry: " moe
        read -p "Gender: " gender
        read -p "Height: " height
        read -p "Weight: " weight
        read -p "Index: " index

        echo " $name|$loc|$state|$age|$moe|$gender|$height|$weight|$index " >> BMI_2022.dat

elif [ $choice -eq 2 ]
then
        cat -n BMI_2022.dat

        echo " "

        echo "Now we are gonna solve the questions: "
        echo " "

        echo "1.Sorting by the location: "
        echo " "
        sort -t "|" -k 2 BMI_2022.dat

        echo "----------------------------------------------------------------------- "

        echo "2. Sorting by the State: "
        echo " "
        sort -t "|" -k 3 BMI_2022.dat

        echo "-----------------------------------------------------------------------"

        echo "3. Sorting based on BMI Index: "
        echo " "
        sort -t "|" -k 9 BMI_2022.dat

        echo "----------------------------------------------------------------------- "

        echo "4. Sorting based on state and then location: "
        echo " "
        sort -t "|" -k 3 -k 2 BMI_2022.dat

        echo "----------------------------------------------------------------------- "

        echo "5. Displaying the Row no, Name, Age, Gender and BMI Columns: "
        echo " "
        cut -d "|" -f 1,4,6,9 BMI_2022.dat

        echo "----------------------------------------------------------------------- "

        echo "6. Changing all names into upper case: "
        echo " "

        echo "-------------------------------------------------------------------------"

        echo "7. Sorting all records based on age: "
        echo " "
        sort -t "|" -k 4 -n BMI_2022.dat

        echo "----------------------------------------------------------------------- "

        echo "8. Displaying all records ordered on Month in another file: "

        echo "----------------------------------------------------------------------- "

        echo "9. Displaying all records where names begin with S and J in another file: "
        echo "----------------------------------------------------------------------- "

        echo "10. Moving columns Name,Location,State,Age and Index into new file after sorting on Name Field: "

        echo "----------------------------------------------------------------------- "

else
echo "Thank You!"
fi




					WEEK-5

					SCHEDULING ALGORITHMS

					FCFS
/*
 * Name: Atyam V V R Manoj
 * Registration number: 200968108
 * Program: Implementing FCFS CPU Scheduling in C
 * Date: 09/09/2022
 */

#include<stdio.h>
int main() {
        int pid[3], at[3], bt[3];
        printf("Enter the Process IDs: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &pid[i]);
        printf("Enter the arrival times: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &at[i]);
        printf("Enter the burst times: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &bt[i]);
        int order[3] = {1,2,3}, at_copy[3];
        for(int i = 0; i < 3; i++)
                at_copy[i] = at[i];
        for(int i = 0; i < 3 - 1; i++)
                for(int j = 0; j < 3 - i - 1; j++)
                        if(at_copy[j] > at_copy[j+1]) {
                                int temp = at_copy[j];
                                at_copy[j] = at_copy[j+1];
                                at_copy[j+1] = temp;
                                temp = order[j];
                                order[j] = order[j+1];
                                order[j+1] = temp;
                        }
        int finish_time[3], wt[3], tat[3], time = 0;
        for(int i = 0; i < 3; i++) {
                int curr = order[i];
                if(time < at[curr-1])
                        time = at[curr-1];
                time += bt[curr-1];
                finish_time[curr-1] = time;
                wt[curr-1] = time - bt[curr-1] - at[curr-1];
                tat[curr-1] = wt[curr-1] + bt[curr-1];
        }
        float avgwt = (wt[0] + wt[1] + wt[2]) / 3.0;
        float avgtat = (tat[0] + tat[1] + tat[2]) / 3.0;
        printf("Finish times: ");
	for(int i = 0; i < 3; i++)
                printf("%d ", finish_time[i]);
        printf("\nWaiting times: ");
        for(int i = 0; i < 3; i++)
                printf("%d ", wt[i]);
        printf("\nTurn Arount times: ");
        for(int i = 0; i < 3; i++)
                printf("%d ", tat[i]);
        printf("\nAverage waiting time: %.2f", avgwt);
        printf("\nAverage turn around time: %.2f \n", avgtat);
        return 0;
}


					SJF

/*
 * Name: Atyam V V R Manoj
 * Registration number: 200968108
 * Program: Implementing SJF CPU Scheduling in C
 * Date: 09/09/2022
 */

#include<stdio.h>

int main() {
        int pid[3], at[3], bt[3];
        printf("Enter the Process IDs: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &pid[i]);
        printf("Enter the arrival times: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &at[i]);
        printf("Enter the burst times: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &bt[i]);
        //SJF
        int order[3] = {1,2,3}, bt_copy[3];
        for(int i = 0; i < 3; i++)
                bt_copy[i] = bt[i];
        for(int i = 0; i < 3 - 1; i++)
                for(int j = 0; j < 3 - i - 1; j++)
                        if(bt_copy[j] > bt_copy[j+1]) {
                                int temp = bt_copy[j];
                                bt_copy[j] = bt_copy[j+1];
                                bt_copy[j+1] = temp;
                                temp = order[j];
                                order[j] = order[j+1];
                                order[j+1] = temp;
                        }
        int finish_time[3], wt[3], tat[3], time = 0;
        for(int i = 0; i < 3; i++) {
                int curr = order[i];
                wt[curr-1] = time;
                time += bt[curr-1];
                finish_time[curr-1] = time;
                tat[curr-1] = wt[curr-1] + bt[curr-1];
        }
        float avgwt = (wt[0] + wt[1] + wt[2]) / 3.0;
        float avgtat = (tat[0] + tat[1] + tat[2]) / 3.0;
        printf("Finish times: ");
        for(int i = 0; i < 3; i++)
                printf("%d ", finish_time[i]);
        printf("\nWaiting times: ");
        for(int i = 0; i < 3; i++)
                printf("%d ", wt[i]);
        printf("\nTurn Around times: ");
        for(int i = 0; i < 3; i++)
                printf("%d ", tat[i]);
        printf("\nAverage waiting time: %.2f", avgwt);
        printf("\nAverage turn around time: %.2f \n", avgtat);
	return 0;
}


#include<stdio.h>
#include<stdlib.h>

void swap(int *x, int *y){
        int temp = *x;
        *x = *y;
        *y = temp;
}

void printArr(int arr[], int n){
        for(int i = 0; i < n; i++){
                printf("%d ", arr[i]);
        }
        printf("\n");
}

int main(){
        //printf("Hello, World!\n");
        int n;

        printf("Enter size of the array: ");
        scanf("%d", &n);

        int pid[n];
        int arrival[n];
        int burst[n];

        for (int i = 0; i < n; i++){
                printf("Enter process id: ");
                scanf("%d", &pid[i]);

                printf("Enter arrival time: ");
                scanf("%d", &arrival[i]);

                printf("Enter burst time: ");
                scanf("%d", &burst[i]);
        }

        //sorting based  on arrival time
        for (int i = 0; i < n-1; i++){
                for (int j = 0; j < n-i-1; j++){
                        if (burst[j] > burst[j+1]){

                                swap(&arrival[j], &arrival[j+1]);
                                swap(&pid[j], &pid[j+1]);
                                swap(&burst[j], &burst[j+1]);
                        }
                }
        }

        //waiting time
        int wait[n];
        float avg_wait = 0.0f;
        wait[0] = arrival[0];
        for (int i = 1; i < n+1; i++){
		wait[i] = wait[i-1] + burst[i-1];
                printf("%d ", wait[i]);
                avg_wait += wait[i] / n;
        }
        printf("\n");
        printf("Average Waiting Time is: %.2f", avg_wait);
        printf("\n");

        //turnaround time
        int tat[n];
        float avg_tat = 0.0f;
        for (int i = 0; i < n; i++){
                tat[i] = wait[i] + burst[i];
                printf("%d ", tat[i]);
                avg_tat += tat[i] / n;
        }
        printf("\n");
        printf("Average Turn Around Time is: %.2f", avg_tat);
        printf("\n");

        //print
        printArr(pid, n);
        printArr(arrival, n);
        printArr(burst, n);


        //printf("%d ", n);
        return 0;
}


struct process{
                int pid;
                float bt;
                float at;
};

int main(){
        int num,i,j,cnt=0;
        printf("Enter number of process: ");
        scanf("%d",&num);
        if(!num){
                printf("Number of Processes cannot be zero!");
                exit(0);
        }
        struct process prc[num];
        float wt[num],tat[num],rm[num];
        float awt=0,atat=0;
        printf("Enter the arrival and burst time for the processes: \n");
        for(i=0;i<num;i++){
                printf("Process %d: ",i+1);
                prc[i].pid=i+1;
                scanf("%f %f",&prc[i].at,&prc[i].bt);
        }


        for(i=0;i<num;i++)
                rm[i] = prc[i].bt;

        int t=0,min=TMP_MAX, srt=0, et, check=0;

        while(cnt!=num){
                for(i=0;i<num;i++){
                        if(prc[i].at<=t && rm[i] < min && rm[i]>0){
                                min = rm[i];
                                srt = i;
                                check = 1;
                         }
                }


                if(!check){
			t++;
                        continue;
                }

                rm[srt]--;
                min = rm[srt];


                if(!min)
                        min=TMP_MAX;

                if(rm[srt] ==0){
                        cnt++;
                        check=0;


                        et=t+1;

                        wt[srt]= et - prc[srt].bt - prc[srt].at;

                        if(wt[srt] <0)
                                wt[srt]=0;
                }
                t++;
        }
        for(i=0;i<num;i++){
                tat[i] = prc[i].bt + wt[i];
        }
        printf("Process ID\tArrival Time\tBurst Time\tWaiting time\tTurn Around Time\n");
        for(i=0;i<num;i++){
                awt += wt[i];
                atat += tat[i];
                printf("%d\t\t %.2f \t\t %.2f \t\t %.2f\n",prc[i].pid, prc[i].bt, wt[i],tat[i]);
        }
        printf("\nAverage waiting time = %.2f ",awt / (float)num);
        printf("\nAverage turn around time = %.2f\n",atat / (float)num);

        return 0;
}

					srtf

struct process{
        int pid;
        float bt;
        float at;
};

int main(){
        int num,i,j,cnt=0;
        printf("Enter number of process: ");
        scanf("%d",&num);
        if(!num){
                printf("Number of Processes cannot be zero!");
                exit(0);
        }
        struct process prc[num];
        float wt[num],tat[num],rm[num];
        float awt=0,atat=0;
        printf("Enter the arrival and burst time for the processes: \n");
        for(i=0;i<num;i++){
                printf("Process %d: ",i+1);
                prc[i].pid=i+1;
                scanf("%f %f",&prc[i].at,&prc[i].bt);
        }

        for(i=0;i<num;i++)
                rm[i] = prc[i].bt;
        int t=0,min=TMP_MAX, srt=0, et, check=0;


        while(cnt!=num){
                for(i=0;i<num;i++){
                        if(prc[i].at<=t && rm[i] < min && rm[i]>0){
                                min = rm[i];
                                srt = i;
                                check = 1;
                        }
                }


                if(!check){
                        t++;
			continue;
                }

                rm[srt]--;
                min = rm[srt];

                if(!min)
                        min=TMP_MAX;

                if(rm[srt] ==0){
                        cnt++;
                        check=0;

                        et=t+1;

                        wt[srt]= et - prc[srt].bt - prc[srt].at;

                        if(wt[srt] <0)
                                wt[srt]=0;
                }
                t++;
        }

        for(i=0;i<num;i++){
                tat[i] = prc[i].bt + wt[i];
        }
        printf("Process ID\tArrival Time\tBurst Time\tWaiting time\tTurn Around Time\n");
        for(i=0;i<num;i++){
                awt += wt[i];
                atat += tat[i];
                printf("%d\t\t %.2f \t\t %.2f \t\t %.2f\n",prc[i].pid, prc[i].bt, wt[i],tat[i]);
        }
        printf("\nAverage waiting time = %.2f ",awt / (float)num);
        printf("\nAverage turn around time = %.2f\n",atat / (float)num);

        return 0;
}

					RR

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>  
#include <sys/wait.h>   
#include <unistd.h>     
typedef struct{
int pid;
int arrival_time;
int burst_time;
int rem_time;
int priority;
}Process;
Process* Entry(){
printf("Enter the number of processes:");
int n;
scanf("%d", &n);
Process* p = (Process*) malloc( n+1 * sizeof(Process) );
printf("Enter PID, arrival, burst, Priority ( Enter 0 for default )\n");
for(int i=0;i<n;i++){
printf("Process %d :",i+1);
scanf("%d %d %d %d", &p[i].pid, &p[i].arrival_time, &p[i].burst_time, &p[i].priority);
p[i].rem_time=p[i].burst_time;
}
p[n].pid=-1;
return p;
}
int min(Process *p, int n, int timer){
int min_time=9999;
int min=-1;
for(int i=0;i<n;i++){
if(p[i].arrival_time<=timer && p[i].rem_time>0 && p[i].burst_time<min_time){
min_time=p[i].burst_time;
min=i;
}
}
return min;
}
void RR(){
Process* p = Entry();
int n=0;
while(p[n].pid!=-1)
n++;
int q;
printf("Enter time slice:");
scanf("%d", &q);
int timer=0;
int done=0;
float TAT=0;
float WAT=0;
while(done!=n){
for(int i=0;i<n;i++){
int count=q;
int start=timer;
while(p[i].rem_time>0 && p[i].arrival_time<=timer && count>0){
timer++;
p[i].rem_time--;
count--;
}
if(start!=timer){
printf("%d -> (%d %d)\n", p[i].pid, start, timer);
if(p[i].rem_time==0){
TAT+=(timer-p[i].arrival_time);
WAT+=(timer-p[i].arrival_time-p[i].burst_time);;
done++;
}
}
}
}
TAT=TAT/n;
WAT=WAT/n;
printf("Turnaround Time = %0.2f ms \n", TAT);
printf("Waiting Time = %0.2f ms\n\n\n", WAT);
}

int comparator(const void* p, const void* q) { 
return ((Process*)p)->arrival_time > ((Process*)q)->arrival_time && ((Process*)p)->priority > ((Process*)q)->priority;
}



int main(){
RR();
}

				Preemptive Priority
#include<stdio.h>
struct priority_scheduling{
char process_name;
int burst_time;
int waiting_time;
int turn_around_time;
int priority;
 };
int main()
{
int number_of_process;
int total=0;
struct priority_scheduling temp_process;
int ASCII_number=65;
int position;
float average_waiting_time;
float average_turnaround_time;
printf("Enter the total number of Processes: ");
scanf("%d",&number_of_process);
struct priority_scheduling process[number_of_process];
printf("\nPlease Enter the  Burst Time and Priority of each process:\n");
for(int i=0;i<number_of_process;i++){
process[i].process_name=(char)ASCII_number;
printf("\nEnter the details of the process %c \n", process[i].process_name);
printf("Enter the burst time: ");
scanf("%d",&process[i].burst_time);
printf("Enter the priority: ");
scanf("%d",&process[i].priority);
ASCII_number++;       
}
for(int i=0;i<number_of_process;i++){
position=i;
for(int j=i+1;j<number_of_process;j++)
{
if(process[j].priority>process[position].priority)
position=j;
}
temp_process=process[i];
process[i]=process[position];
process[position]=temp_process;
}
process[0].waiting_time=0; 
for(int i=1;i<number_of_process;i++){
process[i].waiting_time=0;
for(int j=0;j<i;j++){
process[i].waiting_time+=process[j].burst_time;
}
total+=process[i].waiting_time;
}
average_waiting_time=(float)total/(float)number_of_process;      
total=0;
printf("\n\nProcess_name \t Burst Time \t Waiting Time \t  Turnaround Time\n");
printf("------------------------------------------------------------\n");
for(int i=0;i<number_of_process;i++){
process[i].turn_around_time=process[i].burst_time+process[i].waiting_time;  
total+=process[i].turn_around_time;
printf("\t  %c \t\t\t  %d \t\t\t %d \t\t\t\t %d",process[i].process_name,process[i].burst_time,process[i].waiting_time,process[i].turn_around_time);
printf("\n-----------------------------------------------------------\n");
}
average_turnaround_time=total/number_of_process;     
printf("\n\n Average Waiting Time :%f",average_waiting_time);
printf("\n Average Turnaround Time: %f\n",average_turnaround_time);
return 0;
}


				non preemptive priority

#include <stdlib.h>
#include <stdio.h>
void main()
{
int pn = 0;                 
int CPU = 0;            
int allTime = 0;       
printf("Enrer Processes Count: ");
scanf("%d",&pn);
int AT[pn];
int ATt[pn];
int NoP = pn;
int PT[pn];            
int PP[pn];            
int PPt[pn];
int waittingTime[pn];
int turnaroundTime[pn];
int i=0;
for(i=0 ;i<pn ;i++){
printf("\nProcessing time for P%d: ",i+1);
scanf("%d",&PT[i]);
printf("Piriorty for P%d: ",i+1);
scanf("%d",&PP[i]);
PPt[i] = PP[i];
printf("Arrival Time for P%d: ",i+1);
scanf("%d",&AT[i]);
ATt[i] = AT[i];
}
int LAT = 0;        
for(i = 0; i < pn; i++)
if(AT[i] > LAT)
LAT = AT[i];
int MAX_P = 0;        
for(i = 0; i < pn; i++)
if(PPt[i] > MAX_P)
MAX_P = PPt[i];
int ATi = 0;       
int P1 = PPt[0];     
int P2 = PPt[0];     
int j = -1;
while(NoP > 0 && CPU <= 1000){
for(i = 0; i < pn; i++){
if((ATt[i] <= CPU) && (ATt[i] != (LAT+10))){
if(PPt[i] != (MAX_P+1)){
P2 = PPt[i];
j= 1;
if(P2 < P1){
j= 1;
ATi = i;
P1 = PPt[i];
P2 = PPt[i];
}
}
}}

if(j == -1){
CPU = CPU+1;
continue;
}else{
waittingTime[ATi] = CPU - ATt[ATi];
CPU = CPU + PT[ATi];
turnaroundTime[ATi] = CPU - ATt[ATi];
 ATt[ATi] = LAT +10;
j = -1;
PPt[ATi] = MAX_P + 1;
ATi = 0;        
P1 = MAX_P+1;   
P2 = MAX_P+1;     
NoP = NoP - 1;
}
}
printf("\nPN\tPT\tPP\tAT\tWT\tTT\n\n");
for(i = 0; i < pn; i++){
printf("P%d\t%d\t%d\t%d\t%d\t%d\n",i+1,PT[i],PP[i],AT[i],waittingTime[i],turnaroundTime[i]);
}
int AvgWT = 0;
int AVGTaT = 0;
for(i = 0; i < pn; i++){
AvgWT = waittingTime[i] + AvgWT;
AVGTaT = turnaroundTime[i] + AVGTaT;
}
printf("AvgWaittingTime = %d\nAvgTurnaroundTime = %d\n",AvgWT/pn,AVGTaT/pn);
}


struct process{
        int pid;
        float bt;
        float at;
        int pr;
};

int main(){
        int num,i,j,cnt=0;
        printf("Enter number of process: ");
        scanf("%d",&num);
        if(!num){
                printf("Number of Processes cannot be zero!");
                exit(0);
        }
        struct process prc[num];
        float wt[num],tat[num],rm[num];
        float awt=0,atat=0;
        printf("Enter the arrival and burst time and priority for the processes: \n");
        for(i=0;i<num;i++){
                printf("Process %d: ",i+1);
                prc[i].pid=i+1;
                scanf("%f %f %d",&prc[i].at,&prc[i].bt,&prc[i].pr);
        }
        for(i=0;i<num;i++){
                int min=i;
                for(j=i+1;j<num;j++){
                        if(prc[j].pr < prc[min].pr)
                                min=j;
                }
                struct process temp=prc[i];
                prc[i] = prc[min];
                prc[min] = temp;
        }
        for(i=0;i<num;i++)
                rm[i] = prc[i].bt;
        int t=0,min=TMP_MAX, srt=0, et, check=0;

        int prior=TMP_MIN;

        while(cnt!=num){
		for(i=0;i<num;i++){
                        if(prc[i].at<=t && prc[i].pr>prior){
                                prior = prc[i].pr;
                                min = rm[i];
                                srt = i;
                                check = 1;
                        }
                }


                if(!check){
                        t++;
                        continue;
                }

                rm[srt]--;
                min = rm[srt];

                if(!min)
                        min=TMP_MAX;

                if(rm[srt] ==0){
                        cnt++;
                        check=0;

                        et=t+1;

                        wt[srt]= et - prc[srt].bt - prc[srt].at;

                        if(wt[srt] <0)
                                wt[srt]=0;
                }
                t++;
        }

        for(i=0;i<num;i++){
                tat[i] = prc[i].bt + wt[i];
        }

        printf("Process ID\tArrival Time\tBurst Time\tWaiting time\tTurn Around Time\n");
        for(i=0;i<num;i++){
                awt += wt[i];
                atat += tat[i];
                printf("%d\t\t %.2f \t\t %.2f \t\t %.2f\n",prc[i].pid, prc[i].bt, wt[i],tat[i]);
        }
        printf("\nAverage waiting time = %.2f ",awt / (float)num);
        printf("\nAverage turn around time = %.2f\n",atat / (float)num);

        return 0;
}



					Week-6

/*
 * Name: Atyam V V R Manoj
 * Reg No. : 200968108
 * Date: 
 * Program: 
*/

#include<stdio.h>
#include<pthread.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>


1


void* threadCode(void *param){
        printf("Greetings! from thread code\n");

}
int main(){
        printf("Enter the no. of integers to enter: ";
        int num,dig;
        scanf("%d",&num);
        int arr[num];
        for(int i=0;i<num;i++){
                scanf("%d",&dig)
                if(dig<0){
                        printf("Negative values not allowed!\n");
                        i--;
                }
                else
                        arr[i]=dig;
        }
        pthread_t thread;
        pthread_create(&thread,NULL,&threadCode,&arr[0]);
        printf("Greetings! from the Main Thread!\n");
        pthread_join(thread,0);
        return 0;
}


2

#include<stdio.h>
#include<pthread.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>

int n;

void* add_even(void* param) {
        int *arr = (int*) param;
        int sum = 0;
        for(int i = 0; i < n; i++) {
                if(arr[i] % 2 == 0)
                        sum += arr[i];
        }
        return (void*) sum;
}

void* add_odd(void* param) {
        int *arr = (int*) param;
        int sum = 0;
        for(int i = 0; i < n; i++) {
                if(arr[i] % 2 != 0)
                        sum += arr[i];
        }
        return (void*) sum;
}

int main() {
        printf("Enter the number of integers: ");
        scanf("%d", &n);
        int *arr = (int*) malloc(n * sizeof(int));
        printf("Enter %d integers: ", n);
        for(int i = 0; i < n; i++)
                scanf("%d", &arr[i]);
        pthread_t thread_even, thread_odd;
        int sum_even, sum_odd;
        pthread_create(&thread_even, NULL, &add_even, (void*) arr);
        pthread_create(&thread_odd, NULL, &add_odd, (void*) arr);
        pthread_join(thread_even, (void**) &sum_even);
        pthread_join(thread_odd, (void**) &sum_odd);
        printf("The sum of the even integers is: %d\n", sum_even);
        printf("The sum of the odd integers is: %d\n", sum_odd);
        free(arr);
}

	1. Summation.c

#include<stdio.h>
#include<pthread.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>

int n;

void* sum_positive(void* param) {
        int *arr = (int*) param;
        int sum = 0;
        for(int i = 0; i < n; i++) {
                if(arr[i] > 0)
                        sum += arr[i];
        }
        return (void*) sum;
};

int main() {
        printf("Enter the number of integers: ");
        scanf("%d", &n);
        int *arr = (int*) malloc(n * sizeof(int));
        printf("Enter %d integers: ", n);
        for(int i = 0; i < n; i++)
                scanf("%d", &arr[i]);
        pthread_t thread;
        int sum;
        pthread_create(&thread, NULL, &sum_positive, (void*) arr);
        pthread_join(thread, (void**) &sum);
        printf("The sum of non-negative integers is: %d\n", sum);
        free(arr);
}

	Exer_1.c

#include<stdio.h>
#include<pthread.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>

int size;
void* threadCode(void* param){
        int* arr = (int*)param;
        int sum=0,*p=&sum;
        for(int i=0;i<size;i++){
                sum += arr[i];
        }
        printf("%d",sum);
        return (void*)*p;
}
int main(){
        int sum,arr[30];
        pthread_t thread;
        printf("Enter no. of Entries: ");
        scanf("%d",&size);
        printf("Enter non negative numbers\n");
        for(int i=0;i<size;i++){
                scanf("%d",&arr[i]);
                if(arr[i] < 0)
                        i--;
        }
        pthread_create(&thread,NULL,&threadCode,(void*)&arr);
        pthread_join(thread,(void**)sum);
        printf("%d\n",sum);
        return 0;
}

	2.odd_even_sum.c

#include<stdio.h>
#include<pthread.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>

int n;

void* add_even(void* param) {
        int *arr = (int*) param;
        int sum = 0;
        for(int i = 0; i < n; i++) {
                if(arr[i] % 2 == 0)
                        sum += arr[i];
        }
        return (void*) sum;
}

void* add_odd(void* param) {
        int *arr = (int*) param;
        int sum = 0;
        for(int i = 0; i < n; i++) {
                if(arr[i] % 2 != 0)
                        sum += arr[i];
        }
        return (void*) sum;
}

int main() {
        printf("Enter the number of integers: ");
        scanf("%d", &n);
        int *arr = (int*) malloc(n * sizeof(int));
        printf("Enter %d integers: ", n);
        for(int i = 0; i < n; i++)
                scanf("%d", &arr[i]);
        pthread_t thread_even, thread_odd;
        int sum_even, sum_odd;
        pthread_create(&thread_even, NULL, &add_even, (void*) arr);
        pthread_create(&thread_odd, NULL, &add_odd, (void*) arr);
        pthread_join(thread_even, (void**) &sum_even);
        pthread_join(thread_odd, (void**) &sum_odd);
        printf("The sum of the even integers is: %d\n", sum_even);
        printf("The sum of the odd integers is: %d\n", sum_odd);
        free(arr);
}
              
	Exer_2.c

int arr[50], size;

void* evenSum(void* param){
        int sum = (int)param;
        for(int i=0;i<size;i++){
                if(arr[i]%2==0)
                        sum += arr[i];
        }
        return (void*)sum;
}
void* oddSum(void* param){
        int sum = (int)param;
        for(int i=0;i<size;i++){
                if(arr[i]%2!=0)
                        sum += arr[i];
        }
        return (void*)sum;
}
int main(){
        pthread_t th1,th2;
        int e_sum=0,o_sum=0;
        printf("Enter tha array size: ");
        scanf("%d",&size);
        printf("Enter the array elements: ");
        for(int i=0;i<size;i++)
                scanf("%d",&arr[i]);
        pthread_create(&th1,NULL,&evenSum,(void*)e_sum);
        pthread_create(&th2,NULL,&oddSum,(void*)o_sum);
        pthread_join(th1,(void**)&e_sum);
        pthread_join(th2,(void**)&o_sum);
        printf("Even Sum: %d\n",e_sum);
        printf("Odd Sum: %d\n",o_sum);
        return 0;
}

	3.find_primes.c

#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>

int num_primes = 0;

_Bool isprime(int x) {
        _Bool prime = 1;
        for(int i = 3; i < x/2; i++) {
                if(x % i == 0) {
                        prime = 0;
                        break;
                }
        }
        return prime;
}

void* find_primes(void* param) {
        int *arr = (int*) param;
        int ans[100];
        for(int i = arr[0]; i <= arr[1]; i++) {
                if(isprime(i))
                        ans[num_primes++] = i;
        }
        return (void*) ans;
}

int main() {
        int data[2];
        printf("Enter the lower limit: ");
        scanf("%d", &data[0]);
        printf("Enter the upper limit: ");
        scanf("%d", &data[1]);
        pthread_t thread;
        pthread_create(&thread, NULL, &find_primes, (void*) data);
        int primes[100];
        pthread_join(thread, (void**) &primes);
        printf("The primes numbers are: ");
        for(int i = 0; i < num_primes; i++)
                printf("%d ", primes[i]);
        printf("\n");
}      

	Exer_3.c

int upper,lower;

void* threadCode(void* param){
        int i,prime;
        for(i=upper;i<=lower;i++){
                prime=1;
                for(int j=2;j<=i/2;j++){
                        if(i%j == 0 ){
                                prime=0;
                                break;
                        }
                }
                if(prime)
                        printf("%d\n",i);
        }
}

int main(){
        pthread_t thread;
        printf("Enter the range for prime numbers: ");
        scanf("%d %d",&upper,&lower);
        pthread_create(&thread,NULL,&threadCode,NULL);
        pthread_join(thread,0);
        return 0;
}


	4.fibonacci.c


int *fib;
void* generate_seq(void* param){
        int n = (int) param;
        int first=0;
        int second=1;
        fib[0]=0;
        for(int i=1;i<n;i++){
                int temp = first;
                first += second;
                second = temp;
                fib[i] = first;
        }
        return (void*)n;
}

int main(){
        int n;
        printf("Enter the no. of Fibonacci to generate: ");
        scanf("%d",&n);
        fib = (int*) malloc(n*sizeof(int));
        pthread_t thread;
        pthread_create(&thread,NULL,&generate_seq,(void*)n);
        pthread_join(thread,NULL);
        for(int i=0;i<n;i++)
                printf("%d\t",fib[i]);
        free(fib);
        return 0;
}


					Week-7


		Exer_1.c


/*
 * Name: Atyam V V R Manoj
 * Reg No. : 200968108
 * Date: 
 * Program: 
*/

#include<stdio.h>
#include<pthread.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>

int capacity;
int *queue;
int max;
sem_t full, empty;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *producer(void * param)
{
        int in = 0;
        int i;

        for(i = 0; i < max ; i++)
        {
                sem_wait(&empty);
                pthread_mutex_lock(&mutex);
                queue[in] = i+1;
                in = (in+1)%capacity;
                printf("Produced %d\n", i+1);
                pthread_mutex_unlock(&mutex);
                sem_post(&full);
        }
}

void *consumer(void *param)
{
        int out = 0;
        int i;

        for(i = 0; i < max ; i++)
        {
                sem_wait(&full);
                pthread_mutex_lock(&mutex);
                printf("Consumed %i\n", queue[out]);
                out = (out+1)%capacity;
                pthread_mutex_unlock(&mutex);
                sem_post(&empty);
        }
}

int main()
{
        printf("Enter the size of the buffer: ");
        scanf("%d", &capacity);

        printf("Enter the number of items to produce: ");
        scanf("%d", &max);

        queue = (int*)malloc((capacity) *sizeof(int));
        pthread_t prod, cons;
        sem_init(&full, 0, 0);
        sem_init(&empty, 0, capacity);
        pthread_create(&prod, 0, producer, 0);
        pthread_create(&cons, 0, consumer, 0);
        pthread_join(prod, 0);
        pthread_join(cons, 0);
        sem_destroy(&full);

        return 0;
}



				Exer_2.c


sem_t db, mutex;
int readcount = 0;

void *writer(void *a)
{
        int arg = (int)a;
        sem_wait(&db);
        printf("W - Writer %d is operating\n", arg);
        printf("W - Writer %d is done\n", arg);
        sem_post(&db);
}

void *reader(void *a)
{
        int arg = (int) a;
        sem_wait(&mutex);
        readcount++;
        if(readcount == 1)
                sem_wait(&db);
        sem_post(&mutex);
        printf("R - Reader %d is operating\n", arg);
        sem_wait(&mutex);
        readcount--;
        if(readcount == 0)
                sem_post(&db);
        printf("R - Reader %d is done\n", arg);
        sem_post(&mutex);
}

int main()
{
        int r, w;

        printf("Enter the number of Readers: ");
        scanf("%d", &r);

        printf("Enter the number of Writers: ");
        scanf("%d", &w);

        pthread_t readers[r], writers[w];

        sem_init(&mutex, 0, 1);
        sem_init(&db, 0, 1);
        int i = 0;

        while(i<r || i<w)
        {
                if(i<r)
			pthread_create(&readers[i], NULL, reader, (void *)i+1);
                if(i<w)
                        pthread_create(&writers[i], NULL, writer, (void *)i+1);

                i++;
        }

        i = 0;

        while(i<r || i<w)
        {
                if(i<r)
                        pthread_join(readers[i], NULL);
                if(i<w)
                        pthread_join(writers[i], NULL);

                i++;
        }

        sem_destroy(&mutex);
        sem_destroy(&db);

        return 0;
}



			1


/*
 * Name: Atyam V V R Manoj
 * Reg No. : 200968108
 * Date: 
 * Program: 
*/

#include<stdio.h>
#include<semaphore.h>
#include<stdlib.h>
#include<sys/wait.h>

int capacity;
int *queue;
int max;
sem_t full, empty;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;



void *producer(void * param)
{
        int in = 0;
        int i;



       for(i = 0; i < max ; i++)
                        {
                                sem_wait(&empty);
                                pthread_mutex_lock(&mutex);
                                queue[in] = i+1;
                                in = (in+1)%capacity;
                                printf("Produced %d\n", i+1);
                                pthread_mutex_unlock(&mutex);
                                sem_post(&full);
                        }
}



void *consumer(void *param)
{
        int out = 0;
        int i;

       for(i = 0; i < max ; i++)
        {
                sem_wait(&full);
                pthread_mutex_lock(&mutex);
                printf("Consumed %i\n", queue[out]);
                out = (out+1)%capacity;
                pthread_mutex_unlock(&mutex);
                sem_post(&empty);
        }
}

int main()
{
        printf("Enter the size of the buffer: ");
        scanf("%d", &capacity);

       printf("Enter the number of items to produce: ");
        scanf("%d", &max);
       queue = (int*)malloc((capacity) *sizeof(int));
        pthread_t prod, cons;
        sem_init(&full, 0, 0);
        sem_init(&empty, 0, capacity);
        pthread_create(&prod, 0, producer, 0);
        pthread_create(&cons, 0, consumer, 0);
        pthread_join(prod, 0);
        pthread_join(cons, 0);
        sem_destroy(&full);



       return 0;
}

		  2



/*
 * Name: Atyam V V R Manoj
 * Reg No. : 200968108
 * Date: 
 * Program: 
*/

#include<stdio.h>
#include<semaphore.h>
#include<stdlib.h>
#include<sys/wait.h>

sem_t db, mutex;
int readcount = 0;



void *writer(void *a)
{
        int arg = (int)a;
        sem_wait(&db);
        printf("W - Writer %d is operating\n", arg);
        printf("W - Writer %d is done\n", arg);
        sem_post(&db);
}



void *reader(void *a)
{
        int arg = (int) a;
        sem_wait(&mutex);
        readcount++;
        if(readcount == 1)
                sem_wait(&db);
        sem_post(&mutex);
        printf("R - Reader %d is operating\n", arg);
        sem_wait(&mutex);
        readcount--;
        if(readcount == 0)
                sem_post(&db);
        printf("R - Reader %d is done\n", arg);
        sem_post(&mutex);
}



int main()
{
        int r, w;



       printf("Enter the number of Readers: ");
        scanf("%d", &r);



       printf("Enter the number of Writers: ");
        scanf("%d", &w);



       pthread_t readers[r], writers[w];



       sem_init(&mutex, 0, 1);
        sem_init(&db, 0, 1);
        int i = 0;



       while(i<r || i<w)
        {
                if(i<r)
                        pthread_create(&readers[i], NULL, reader, (void *)i+1);
                if(i<w)
                        pthread_create(&writers[i], NULL, writer, (void *)i+1);



               i++;
        }



       i = 0;



       while(i<r || i<w)
        {
                if(i<r)
                        pthread_join(readers[i], NULL);
                if(i<w)
                        pthread_join(writers[i], NULL);



               i++;
        }



       sem_destroy(&mutex);
        sem_destroy(&db);



       return 0;
}

int MAX_ITER=10
int BUFFER_SIZE=10
sem_t empty;
sem_t full;
sem_t mutex;
int in=0;
int out=0;
int buffer[BUFFER_SIZE];
//pthread_mutex mutex;

void* producer(void*param){
        for(int i=0;i<MAX_ITER;i++){
                int item = rand();
                sem_wait(&empty);
                sem_wait(&mutex);
                buffer[in]=item;
                printf("Producer %i : Produced %d at index %d\n",*(int *)param,item,in);
                in = (in+1)%BUFFER_SIZE;
                sem_post(&mutex);
                sem_post(&full);
        }
}
void* consumer(void* param){
        for(int i=0;i<MAX_ITER;i++){
                sem_wait(&full);
                sem_wait(&mutex);
                int val = buffer[out];
                printf("Consumer %i : Consumed %d at index %d\n",*(int *)param,val,out);
                out = (out+1)%BUFFER_SIZE;
                sem_post(&mutex);
                sem_post(&empty);
        }
int main(){
        int i,j,num;
        pthread_t p[5],c[5];
        // 5 Producers
        for(i=0;i<5;i++){
                pthread_create(&p[i],NULL,&producer,(void*)i+1);
        }

        // 5 Consumers
        for(i=0;i<5;i++){
                pthread_create(&c[i],NULL,&consumer,(void*)i+1);
        }

        // Joining Producers and Consumers
        for(i=0;i<5;i++){
                pthread_join(&p[i],NULL);
                pthread_join(&c[i],NULL);
        }

        sem_destroy(&empty);
        sem_destroy(&full);
        sem_destroy(&mutex);
        return 0;
}


					Week-8

	deadlock_avoidance.c


int find_process(int need[5][3], int work[3], _Bool finish[5]) {
        int index = -1;
        for(int i = 0; i < 5; i++) {
                if(finish[i])
                        continue;
                _Bool found = 1;
                for(int j = 0; j < 3; j++)
                        if(need[i][j] > work[j])
                                found = 0;
                if(found) {
                        index = i;
                        break;
                }
        }
        return index;
}

void resource_request(int available[3], int allocation[5][3], int max[5][3
]) {
        int request[3], process_ind;
        printf("Enter the process index for request: ");
        scanf("%d", &process_ind);
        printf("Enter requested number for A, B, C: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &request[i]);
        _Bool possible = 1;
        for(int i = 0; i < 3; i++)
                if(request[i] > available[i] || max[process_ind][i] < (allocation[process_ind][i] + request[i]))
                        possible = 0;
        if(!possible) {
                printf("The requested allocation cannot be made. Proceeding by declining request \n");
                return ;
        }
        for(int i = 0; i < 3; i++) {
                available[i] -= request[i];
                allocation[process_ind][i] += request[i];
        }
}

int main() {
        int available[3], total[3], allocation[5][3], max[5][3];
        printf("Enter the total system resources for A, B, C: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &total[i]);
	printf("Enter the available resources for A, B, C: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &available[i]);
        printf("Enter the allocated resources for each process: \n");
        for(int i = 0; i < 5; i++) {
                printf("P%d: ", i);
                for(int j = 0; j < 3; j++)
                        scanf("%d", &allocation[i][j]);
        }
        printf("Enter the max resources for each process: \n");
        for(int i = 0; i < 5; i++) {
                printf("P%d: ", i);
                for(int j = 0; j < 3; j++)
                        scanf("%d", &max[i][j]);
        }
        resource_request(available, allocation, max);
        int need[5][3];
        printf("The need matrix:");
        for(int i = 0; i < 5; i++) {
                printf("\n");
                printf("P%d: ", i);
                for(int j = 0; j < 3; j++) {
                        need[i][j] = max[i][j] - allocation[i][j];
                        printf("%d ", need[i][j]);
                }
        }
        printf("\n");
        _Bool finish[5];
        for(int i = 0; i < 5; i++)
                finish[i] = 0;
        int process_ind = find_process(need, available, finish);
        while(process_ind != -1) {
                finish[process_ind] = 1;
                for(int i = 0; i < 3; i++)
                        available[i] += allocation[process_ind][i];
                process_ind = find_process(need, available, finish);
        }
        _Bool safe = 1;
        for(int i = 0; i < 5; i++)
                if(!finish[i])
                        safe = 0;
        if(safe)
                printf("The system is in safe state \n");
        else
                printf("The system is not in safe state. \n");
        return 0;
}



	deadlock_detection.c

#include<stdio.h>

int find_process(int request[5][3], int work[3], _Bool finish[5]) {
        int index = -1;
        for(int i = 0; i < 5; i++) {
                if(finish[i])
                        continue;
                _Bool found = 1;
                for(int j = 0; j < 3; j++)
                        if(request[i][j] > work[j])
                                found = 0;
                if(found) {
                        index = i;
                        break;
                }
        }
        return index;
}

int main() {
        int available[3], allocation[5][3], request[5][3];
        printf("Enter the available resources for A, B, C: ");
        for(int i = 0; i < 3; i++)
                scanf("%d", &available[i]);
        printf("Enter the allocated resources for each process: \n");
        for(int i = 0; i < 5; i++) {
                printf("P%d: ", i);
                for(int j = 0; j < 3; j++)
                        scanf("%d", &allocation[i][j]);
        }
        printf("Enter the requested resources for each process: \n");
        for(int i = 0; i < 5; i++) {
                printf("P%d: ", i);
                for(int j = 0; j < 3; j++)
                        scanf("%d", &request[i][j]);
        }
        _Bool finish[5];
        for(int i = 0; i < 5; i++)
                finish[i] = 0;
        int process_ind = find_process(request, available, finish);
        while(process_ind != -1) {
                finish[process_ind] = 1;
		for(int i = 0; i < 3; i++)
                        available[i] += allocation[process_ind][i];
                process_ind = find_process(request, available, finish);
        }
        _Bool safe = 1;
        for(int i = 0; i < 5; i++)
                if(!finish[i])
                        safe = 0;
        if(safe)
                printf("The system is in safe state \n");
        else
                printf("The system is not in safe state. \n");
        return 0;
}


				Week-9

	First-fit.c

#include<stdio.h>

int main() {
        int n_blocks, n_required, block_size[10], required_size[10], available_space[10];
        printf("Enter the number of memory blocks: ");
        scanf("%d", &n_blocks);
        printf("Enter the number of required blocks: ");
        scanf("%d", &n_required);
        printf("Enter the memory block sizes: ");
        for(int i = 0; i < n_blocks; i++)
                scanf("%d", &block_size[i]);
        printf("Enter the required block sizes: ");
        for(int i = 0; i < n_required; i++)
                scanf("%d", &required_size[i]);

        //code logic here
        for(int i = 0; i < n_blocks; i++)
                available_space[i] = block_size[i];
        for(int i = 0; i < n_required; i++) {
                int allocated = 0;
                for(int j = 0; j < n_blocks; j++) {
                        if(required_size[i] <= available_space[j]) {
                                printf("%d size memory block -> %d size process\n", block_size[j], required_size[i]);
                                available_space[j] -= required_size[i];
                                allocated = 1;
                                break;
                        }
                }
                if(!allocated)
                        printf("%d size process is not allocated any block\n", required_size[i]);
        }

        return 0;
}


	Best-fit.c

#include<stdio.h>

int main() {
        int n_blocks, n_required, block_size[10], required_size[10], available_space[10];
        printf("Enter the number of memory blocks: ");
        scanf("%d", &n_blocks);
        printf("Enter the number of required blocks: ");
        scanf("%d", &n_required);
        printf("Enter the memory block sizes: ");
        for(int i = 0; i < n_blocks; i++)
                scanf("%d", &block_size[i]);
        printf("Enter the required block sizes: ");
        for(int i = 0; i < n_required; i++)
                scanf("%d", &required_size[i]);

        //code logic here
        for(int i = 0; i < n_blocks; i++)
                available_space[i] = block_size[i];
        for(int i = 0; i < n_required; i++) {
                int best_index = -1;
                for(int j = 0; j < n_blocks; j++) {
                        if(required_size[i] <= available_space[j]) {
                                if(best_index == -1)
                                        best_index = j;
                                else if(available_space[j] < available_space[best_index])
                                        best_index = j;
                        }
                }
                if(best_index == -1)
                        printf("%d size process is not allocated any block/n",required_sizei]);
                else {
                        printf("%d size memory block -> %d size process\n", block_size[best_index], required_size[i]);
                        available_space[best_index] -= required_size[i];
                }
        }

        return 0;
}


	Worst-fit.c

#include<stdio.h>

int main() {
        int n_blocks, n_required, block_size[10], required_size[10], available_space[10];
        printf("Enter the number of memory blocks: ");
        scanf("%d", &n_blocks);
        printf("Enter the number of required blocks: ");
        scanf("%d", &n_required);
        printf("Enter the memory block sizes: ");
        for(int i = 0; i < n_blocks; i++)
                scanf("%d", &block_size[i]);
        printf("Enter the required block sizes: ");
        for(int i = 0; i < n_required; i++)
                scanf("%d", &required_size[i]);

        //code logic here
        for(int i = 0; i < n_blocks; i++)
                available_space[i] = block_size[i];
        for(int i = 0; i < n_required; i++) {
                int best_index = -1;
                for(int j = 0; j < n_blocks; j++) {
                        if(required_size[i] <= available_space[j]) {
                                if(best_index == -1)
                                        best_index = j;
                                else if(available_space[j] > available_space[best_index])
                                        best_index = j;
                        }
                }
                if(best_index == -1)
                        printf("%d size process is not allocated any block \n",required_size[i]);
                else {
                        printf("%d size memory block -> %d size process\n", block_size[best_index], required_size[i]);
                        available_space[best_index] -= required_size[i];
                }
        }

        return 0;

}



week 10....13 oct 2022



/*
 * Name: Atyam V V R Manoj
 * Reg No. : 200968108
 * Date: 
 * Program: 
*/

#include<stdio.h>
#include<pthread.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>



#include<stdio.h>
int main(){
int i,j,n,a[50],frame[10],no,k,avail,count=0;
            printf("\n ENTER THE NUMBER OF PAGES:\n");
scanf("%d",&n);
            printf("\n ENTER THE PAGE NUMBER :\n");
            for(i=1;i<=n;i++)
            scanf("%d",&a[i]);
            printf("\n ENTER THE NUMBER OF FRAMES :");
            scanf("%d",&no);
for(i=0;i<no;i++)
            frame[i]= -1;
                        j=0;
                        printf("\tref string\t page frames\n");
for(i=1;i<=n;i++)
                        {
                                    printf("%d\t\t",a[i]);
                                    avail=0;
                                    for(k=0;k<no;k++)
if(frame[k]==a[i])
                                                avail=1;
                                    if (avail==0)
                                    {
                                                frame[j]=a[i];
                                                j=(j+1)%no;
                                                count++;
                                                for(k=0;k<no;k++)
                                                printf("%d\t",frame[k]);
}
                                    printf("\n");
}
                        printf("Page Fault Is %d",count);
                        return 0;
}


OUTPUT:

ENTER THE NUMBER OF PAGES:  20
ENTER THE PAGE NUMBER :       7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1
ENTER THE NUMBER OF FRAMES :3
      ref string       page frames
7               7       -1      -1
0               7       0       -1
1               7       0       1
2               2       0       1
0
3               2       3       1
0               2       3       0
4               4       3       0
2               4       2       0
3               4       2       3
0               0       2       3
3
2
1               0       1       3
2               0       1       2
0
1
7               7       1       2
0               7       0       2
1               7       0       1
Page Fault Is 15



#include<stdio.h>
#include<stdlib.h>

int page_hit(int page_no, int memory_status[10], int num_frames) {
        int present_in_memory = 0;
        for(int i = 0; i < num_frames; i++)
                if(memory_status[i] == page_no) {
                        present_in_memory = 1;
                        break;
                }
        return present_in_memory;
}

void load_page_in_memory(int aging[10], int memory_status[10], int page_no, int num_frames) {
        int index = -1;
        for(int i = 0; i < num_frames; i++)
                if(memory_status[i] == -1) {
                        index = i;
                        break;
                }
        if(index != -1) {
               printf("Page %d loaded to memory at frame index %d \n", page_no, index);
               memory_status[index] = page_no;
        }
        else {
                int replacement_idx = 0;
                for(int i = 1; i < num_frames; i++)
                        if(aging[i] > aging[replacement_idx])
                                replacement_idx = i;
                printf("Page number %d is removed from memory frame index %d \n", memory_status[replacement_idx], replacement_idx);
                memory_status[replacement_idx] = page_no;
                printf("Page %d loaded to memory at frame index %d \n", page_no, replacement_idx);
        }
        for(int i = 0; i < num_frames; i++) {
                if(memory_status[i] != -1)
                        aging[i] += 1;
                if(aging[i] > num_frames)
                        aging[i] = 1;
        }
}

int main() {
        int num_pages, num_frames, sequence[20], seq_len;
        printf("Enter the number of pages: ");
        scanf("%d", &num_pages);
        printf("Enter the number of frames memory can fit: ");
        scanf("%d", &num_frames);
        printf("Enter the sequence length: ");
	scanf("%d", &seq_len);
        printf("Enter the sequence: ");
        for(int i = 0; i < seq_len; i++)
                scanf("%d", &sequence[i]);

        // validate sequence
        for(int i = 0; i < seq_len; i++) {
                if(sequence[i] < 0 || sequence[i] > num_pages - 1) {
                        printf("Invalid execution sequence. \n");
                        exit(0);
                }
        }

        //logic here
        int aging[10], memory_status[10], present_in_memory, hits = 0;
        for(int i = 0; i < 10; i++) {
                aging[i] = 0;
                memory_status[i] = -1;
        }
        for(int i = 0; i < seq_len; i++) {
                printf("------------------------------------------------------------- \n");
                present_in_memory = page_hit(sequence[i], memory_status, num_frames);
                if(present_in_memory) {
                        hits += 1;
                        printf("Page number %d is already present in memory. \n", sequence[i]);
                }
                else {
                        load_page_in_memory(aging, memory_status, sequence[i], num_frames);
                }
        }
        printf("------------------------------------------------------------- \n");
        printf("The number of page hits: %d \n", hits);
        printf("The number of page faults: %d \n", seq_len - hits);

        return 0;
}





optimal:
#include<stdio.h>
int main()
{
    int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos, max, faults = 0;
    printf("Enter number of frames: ");
    scanf("%d", &no_of_frames);
    
    printf("Enter number of pages: ");
    scanf("%d", &no_of_pages);
    
    printf("Enter page reference string: ");
    
    for(i = 0; i < no_of_pages; ++i){
        scanf("%d", &pages[i]);
    }
    
    for(i = 0; i < no_of_frames; ++i){
        frames[i] = -1;
    }
    
    for(i = 0; i < no_of_pages; ++i){
        flag1 = flag2 = 0;
        
        for(j = 0; j < no_of_frames; ++j){
            if(frames[j] == pages[i]){
                   flag1 = flag2 = 1;
                   break;
               }
        }
        
        if(flag1 == 0){
            for(j = 0; j < no_of_frames; ++j){
                if(frames[j] == -1){
                    faults++;
                    frames[j] = pages[i];
                    flag2 = 1;
                    break;
                }
            }    
        }
        
        if(flag2 == 0){
         flag3 =0;
        
            for(j = 0; j < no_of_frames; ++j){
             temp[j] = -1;
            
             for(k = i + 1; k < no_of_pages; ++k){
             if(frames[j] == pages[k]){
             temp[j] = k;
             break;
             }
             }
            }
            
            for(j = 0; j < no_of_frames; ++j){
             if(temp[j] == -1){
             pos = j;
             flag3 = 1;
             break;
             }
            }
            
            if(flag3 ==0){
             max = temp[0];
             pos = 0;
            
             for(j = 1; j < no_of_frames; ++j){
             if(temp[j] > max){
             max = temp[j];
             pos = j;
             }
             }            
            }
frames[pos] = pages[i];
faults++;
        }
        
        printf("\n");
        
        for(j = 0; j < no_of_frames; ++j){
            printf("%d\t", frames[j]);
        }
    }
    
    printf("\n\nTotal Page Faults = %d", faults);
    
    return 0;
}



Output

Enter number of frames: 3
Enter number of pages: 10
Enter page reference string: 2 3 4 2 1 3 7 5 4 3

2 -1 -1
2 3 -1
2 3 4
2 3 4
1 3 4
1 3 4
7 3 4
5 3 4
5 3 4
5 3 4






lru:


#include<stdio.h>
 
int findLRU(int time[], int n){
int i, minimum = time[0], pos = 0;
 
for(i = 1; i < n; ++i){
if(time[i] < minimum){
minimum = time[i];
pos = i;
}
}
return pos;
}
 
int main()
{
    int no_of_frames, no_of_pages, frames[10], pages[30], counter = 0, time[10], flag1, flag2, i, j, pos, faults = 0;
printf("Enter number of frames: ");
scanf("%d", &no_of_frames);
printf("Enter number of pages: ");
scanf("%d", &no_of_pages);
printf("Enter reference string: ");
    for(i = 0; i < no_of_pages; ++i){
     scanf("%d", &pages[i]);
    }
    
for(i = 0; i < no_of_frames; ++i){
     frames[i] = -1;
    }
    
    for(i = 0; i < no_of_pages; ++i){
     flag1 = flag2 = 0;
    
     for(j = 0; j < no_of_frames; ++j){
     if(frames[j] == pages[i]){
     counter++;
     time[j] = counter;
   flag1 = flag2 = 1;
   break;
   }
     }
    
     if(flag1 == 0){
for(j = 0; j < no_of_frames; ++j){
     if(frames[j] == -1){
     counter++;
     faults++;
     frames[j] = pages[i];
     time[j] = counter;
     flag2 = 1;
     break;
     }
     }
     }
    
     if(flag2 == 0){
     pos = findLRU(time, no_of_frames);
     counter++;
     faults++;
     frames[pos] = pages[i];
     time[pos] = counter;
     }
    
     printf("\n");
    
     for(j = 0; j < no_of_frames; ++j){
     printf("%d\t", frames[j]);
     }
}
printf("\n\nTotal Page Faults = %d", faults);
    
    return 0;
}


output:Enter number of frames: 3
Enter number of pages: 6
Enter reference string: 5 7 5 6 7 3

5 -1 -1
5 7 -1
5 7 -1
5 7 6
5 7 6
3 7 6

Total Page Faults = 4






				Week5


			srtf.c


/*
 * Name: Atyam V V R Manoj
 * Reg No. : 200968108
 * Date: 
 * Program: 
*/

#include<stdio.h>
#include<pthread.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/wait.h>

struct process{
        int pid;
        float bt;
        float at;
};

int main(){
        int num,i,j,cnt=0;
        printf("Enter number of process: ");
        scanf("%d",&num);
        if(!num){
                printf("Number of Processes cannot be zero!");
                exit(0);
        }
        struct process prc[num];
        float wt[num],tat[num],rm[num];
        float awt=0,atat=0;
        printf("Enter the arrival and burst time for the processes: \n");
        for(i=0;i<num;i++){
                printf("Process %d: ",i+1);
                prc[i].pid=i+1;
                scanf("%f %f",&prc[i].at,&prc[i].bt);
        }

        for(i=0;i<num;i++)
                rm[i] = prc[i].bt;
        int t=0,min=TMP_MAX, srt=0, et, check=0;


        while(cnt!=num){
                for(i=0;i<num;i++){
  ╜                     if(prc[i].at<=t && rm[i] < min && rm[i]>0){
                                min = rm[i];
                                srt = i;
                                check = 1;
                        }
                }


                if(!check){
                        t++;
                        continue;
                }

                rm[srt]--;
                min = rm[srt];

                if(!min)
			min=TMP_MAX;

                if(rm[srt] ==0){
                        cnt++;
                        check=0;

                        et=t+1;

                        wt[srt]= et - prc[srt].bt - prc[srt].at;

                        if(wt[srt] <0)
                                wt[srt]=0;
                }
                t++;
        }

        for(i=0;i<num;i++){
                tat[i] = prc[i].bt + wt[i];
        }
        printf("Process ID\tArrival Time\tBurst Time\tWaiting time\tTurn Around Time\n");
        for(i=0;i<num;i++){
                awt += wt[i];
                atat += tat[i];
                printf("%d\t\t %.2f\t\t %.2f \t\t %.2f \t\t %.2f\n",prc[i].pid, prc[i].at, prc[i].bt, wt[i],tat[i]);
        }
        printf("\nAverage waiting time = %.2f ",awt / (float)num);
        printf("\nAverage turn around time = %.2f\n",atat / (float)num);

        return 0;
}


			rr.c


struct process{
        int pid;
        float bt;
        float at;
};

int main(){
        int num,i,j,cnt=0,q;
        printf("Enter number of process: ");
        scanf("%d",&num);
        if(!num){
                printf("Number of Processes cannot be zero!");
                exit(0);
        }
        struct process prc[num];
        float wt[num],tat[num],rm[num];
        float awt=0,atat=0;
        printf("Enter the Time quantum: ");
        scanf("%d",&q);
        printf("Enter the arrival and burst time for the processes: \n");
        for(i=0;i<num;i++){
                printf("Process %d: ",i+1);
                prc[i].pid=i+1;
                scanf("%f %f",&prc[i].at,&prc[i].bt);
        }

        for(i=0;i<num;i++)
                rm[i] = prc[i].bt;
        int t=0;


        while(1){
                int done=1;

                for(i=0;i<num;i++){
                        if(rm[i] > 0){
                                done=0;
                                if(rm[i]>q){
                                        t+=q;
                                        rm[i] -= q;
                                }
                                else{
                                        t += rm[i];
                                        wt[i] = t - prc[i].bt;
					rm[i] =0;
                                }
                        }
                }


                if(done){
                        break;
                }
        }
        for(i=0;i<num;i++){
                tat[i] = prc[i].bt + wt[i];
        }

        printf("Process ID\tArrival Time\tBurst Time\tWaiting time\tTurn Around Time\n");
        for(i=0;i<num;i++){
                awt += wt[i];
                atat += tat[i];
                printf("P%d\t\t %.2f \t\t %.2f \t\t %.2f \t\t %.2f\n",prc[i].pid, prc[i].at, prc[i].bt, wt[i],tat[i]);
        }
        printf("\nAverage waiting time = %.2f ",awt / (float)num);
        printf("\nAverage turn around time = %.2f\n",atat / (float)num);

        return 0;
}


		preep_np.c

struct process
{
        int id,WT,AT,BT,TAT,PR;
};
struct process a[10];

void swap(int *b,int *c)
{
        int tem;
        tem=*c;
        *c=*b;
        *b=tem;
}

int main()
{
        int n,check_ar=0;
        int Cmp_time=0;
        float Total_WT=0,Total_TAT=0,Avg_WT,Avg_TAT;
        printf("Enter the number of process \n");
        scanf("%d",&n);
        printf("Enter the Arrival time , Burst time and priority of the process\n");
        for(int i=0;i<n;i++)
        {
                scanf("%d%d%d",&a[i].AT,&a[i].BT,&a[i].PR);
                a[i].id=i+1;
                if(i==0)
                        check_ar=a[i].AT;

                if(check_ar!=a[i].AT )
                        check_ar=1;

        }
        if(check_ar!=0)
        {
                for(int i=0;i<n;i++)
                {
                        for(int j=0;j<n-i-1;j++)
                        {
                                if(a[j].AT>a[j+1].AT)
                                {
                                        swap(&a[j].id,&a[j+1].id);
                                        swap(&a[j].AT,&a[j+1].AT);
                                        swap(&a[j].BT,&a[j+1].BT);
                                        swap(&a[j].PR,&a[j+1].PR);
                                }
                        }
                }
	}

        if(check_ar!=0)
        {
                a[0].WT=a[0].AT;
                a[0].TAT=a[0].BT-a[0].AT;
                Cmp_time=a[0].TAT;
                Total_WT=Total_WT+a[0].WT;
                Total_TAT=Total_TAT+a[0].TAT;
                for(int i=1;i<n;i++)
"prior_np.c" [re{donly] 140L, 2518C
                        int min=a[i].PR;
                        for(int j=i+1;j<n;j++)
                        {
                                if(min>a[j].PR && a[j].AT<=Cmp_time)
                                {
                                        min=a[j].PR;
                                        swap(&a[i].id,&a[j].id);
                                        swap(&a[i].AT,&a[j].AT);
                                        swap(&a[i].BT,&a[j].BT);
                                        swap(&a[i].PR,&a[j].PR);

                                }

                        }
                        a[i].WT=Cmp_time-a[i].AT;
                        Total_WT=Total_WT+a[i].WT;
                        Cmp_time=Cmp_time+a[i].BT;

                        a[i].TAT=Cmp_time-a[i].AT;
                        Total_TAT=Total_TAT+a[i].TAT;

                }
        }

        else
        {
                for(int i=0;i<n;i++)
                {
                        int min=a[i].PR;
                        for(int j=i+1;j<n;j++)
                        {
                                if(min>a[j].PR && a[j].AT<=Cmp_time)
                                {
                                        min=a[j].PR;
                                        swap(&a[i].id,&a[j].id);
                                        swap(&a[i].AT,&a[j].AT);
                                        swap(&a[i].BT,&a[j].BT);
				}

                        }
                        a[i].WT=Cmp_time-a[i].AT;

                        Cmp_time=Cmp_time+a[i].BT;
                        a[i].TAT=Cmp_time-a[i].AT;
                        Total_WT=Total_WT+a[i].WT;
                        Total_TAT=Total_TAT+a[i].TAT;

                }

        }

        Avg_WT=Total_WT/n;
        Avg_TAT=Total_TAT/n;
        printf("The process are\n");
        printf("Process ID\tArrival Time\tBurst Time\tWaiting time\tTurn Around Time\n");
        for(int i=0;i<n;i++)
        {
                printf("P%d \t\t%d \t\t%d \t\t%d \t\t%d\n",a[i].id,a[i].AT,a[i].BT,a[i].WT,a[i].TAT);
        }

        printf("Avg waiting time is: %f\n",Avg_WT);
        printf("Avg turn around time is: %f",Avg_TAT);
        return 0;
}


